// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_selections.sql

package generated

import (
	"context"
)

const getUserSelection = `-- name: GetUserSelection :one

SELECT id, device_id, source_type, source_id, selected, updated_at, created_by, projection_version FROM user_selections_projection
WHERE device_id = $1 AND source_type = $2 AND source_id = $3
`

type GetUserSelectionParams struct {
	DeviceID   string `json:"device_id"`
	SourceType string `json:"source_type"`
	SourceID   string `json:"source_id"`
}

// User selections queries
func (q *Queries) GetUserSelection(ctx context.Context, arg GetUserSelectionParams) (UserSelectionsProjection, error) {
	row := q.db.QueryRow(ctx, getUserSelection, arg.DeviceID, arg.SourceType, arg.SourceID)
	var i UserSelectionsProjection
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.SourceType,
		&i.SourceID,
		&i.Selected,
		&i.UpdatedAt,
		&i.CreatedBy,
		&i.ProjectionVersion,
	)
	return i, err
}

const listAvailableAssignmentsForDevice = `-- name: ListAvailableAssignmentsForDevice :many
SELECT DISTINCT asn.id, asn.source_type, asn.source_id, asn.target_type, asn.target_id, asn.sort_order, asn.mode, asn.created_at, asn.created_by, asn.is_deleted, asn.projection_version FROM assignments_projection asn
WHERE asn.mode = 1 AND asn.is_deleted = FALSE
  AND (
    (asn.target_type = 'device' AND asn.target_id = $1)
    OR (asn.target_type = 'device_group' AND asn.target_id IN (
      SELECT m.group_id FROM device_group_members_projection m WHERE m.device_id = $1
    ))
  )
ORDER BY asn.created_at DESC
`

// List all available-mode assignments targeting a device (directly or via groups)
// Used to build the catalog of items a user can select/deselect
func (q *Queries) ListAvailableAssignmentsForDevice(ctx context.Context, targetID string) ([]AssignmentsProjection, error) {
	rows, err := q.db.Query(ctx, listAvailableAssignmentsForDevice, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssignmentsProjection{}
	for rows.Next() {
		var i AssignmentsProjection
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.TargetType,
			&i.TargetID,
			&i.SortOrder,
			&i.Mode,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSelectionsForDevice = `-- name: ListUserSelectionsForDevice :many
SELECT id, device_id, source_type, source_id, selected, updated_at, created_by, projection_version FROM user_selections_projection
WHERE device_id = $1
ORDER BY updated_at DESC
`

func (q *Queries) ListUserSelectionsForDevice(ctx context.Context, deviceID string) ([]UserSelectionsProjection, error) {
	rows, err := q.db.Query(ctx, listUserSelectionsForDevice, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSelectionsProjection{}
	for rows.Next() {
		var i UserSelectionsProjection
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.SourceType,
			&i.SourceID,
			&i.Selected,
			&i.UpdatedAt,
			&i.CreatedBy,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
