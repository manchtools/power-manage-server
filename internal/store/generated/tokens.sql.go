// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tokens.sql

package generated

import (
	"context"
)

const countTokens = `-- name: CountTokens :one
SELECT COUNT(*) FROM tokens_projection
WHERE is_deleted = FALSE
  AND ($1::BOOLEAN OR disabled = FALSE)
`

func (q *Queries) CountTokens(ctx context.Context, dollar_1 bool) (int64, error) {
	row := q.db.QueryRow(ctx, countTokens, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTokensByOwner = `-- name: CountTokensByOwner :one
SELECT COUNT(*) FROM tokens_projection
WHERE is_deleted = FALSE
  AND owner_id = $1
  AND ($2::BOOLEAN OR disabled = FALSE)
`

type CountTokensByOwnerParams struct {
	OwnerID *string `json:"owner_id"`
	Column2 bool    `json:"column_2"`
}

func (q *Queries) CountTokensByOwner(ctx context.Context, arg CountTokensByOwnerParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTokensByOwner, arg.OwnerID, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTokenByHash = `-- name: GetTokenByHash :one
SELECT id, value_hash, name, one_time, max_uses, current_uses, expires_at, created_at, created_by, disabled, is_deleted, projection_version, owner_id FROM tokens_projection
WHERE value_hash = $1 AND is_deleted = FALSE
`

func (q *Queries) GetTokenByHash(ctx context.Context, valueHash string) (TokensProjection, error) {
	row := q.db.QueryRow(ctx, getTokenByHash, valueHash)
	var i TokensProjection
	err := row.Scan(
		&i.ID,
		&i.ValueHash,
		&i.Name,
		&i.OneTime,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Disabled,
		&i.IsDeleted,
		&i.ProjectionVersion,
		&i.OwnerID,
	)
	return i, err
}

const getTokenByID = `-- name: GetTokenByID :one
SELECT id, value_hash, name, one_time, max_uses, current_uses, expires_at, created_at, created_by, disabled, is_deleted, projection_version, owner_id FROM tokens_projection
WHERE id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetTokenByID(ctx context.Context, id string) (TokensProjection, error) {
	row := q.db.QueryRow(ctx, getTokenByID, id)
	var i TokensProjection
	err := row.Scan(
		&i.ID,
		&i.ValueHash,
		&i.Name,
		&i.OneTime,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Disabled,
		&i.IsDeleted,
		&i.ProjectionVersion,
		&i.OwnerID,
	)
	return i, err
}

const getValidToken = `-- name: GetValidToken :one
SELECT id, value_hash, name, one_time, max_uses, current_uses, expires_at, created_at, created_by, disabled, is_deleted, projection_version, owner_id FROM tokens_projection
WHERE value_hash = $1
  AND is_deleted = FALSE
  AND disabled = FALSE
  AND (expires_at IS NULL OR expires_at > NOW())
  AND (max_uses = 0 OR current_uses < max_uses)
`

// Validates a token for device registration
func (q *Queries) GetValidToken(ctx context.Context, valueHash string) (TokensProjection, error) {
	row := q.db.QueryRow(ctx, getValidToken, valueHash)
	var i TokensProjection
	err := row.Scan(
		&i.ID,
		&i.ValueHash,
		&i.Name,
		&i.OneTime,
		&i.MaxUses,
		&i.CurrentUses,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.Disabled,
		&i.IsDeleted,
		&i.ProjectionVersion,
		&i.OwnerID,
	)
	return i, err
}

const listActiveTokens = `-- name: ListActiveTokens :many
SELECT id, value_hash, name, one_time, max_uses, current_uses, expires_at, created_at, created_by, disabled, is_deleted, projection_version, owner_id FROM tokens_projection
WHERE is_deleted = FALSE
  AND disabled = FALSE
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY created_at DESC
`

func (q *Queries) ListActiveTokens(ctx context.Context) ([]TokensProjection, error) {
	rows, err := q.db.Query(ctx, listActiveTokens)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TokensProjection{}
	for rows.Next() {
		var i TokensProjection
		if err := rows.Scan(
			&i.ID,
			&i.ValueHash,
			&i.Name,
			&i.OneTime,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Disabled,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokens = `-- name: ListTokens :many
SELECT id, value_hash, name, one_time, max_uses, current_uses, expires_at, created_at, created_by, disabled, is_deleted, projection_version, owner_id FROM tokens_projection
WHERE is_deleted = FALSE
  AND ($1::BOOLEAN OR disabled = FALSE)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListTokensParams struct {
	Column1 bool  `json:"column_1"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListTokens(ctx context.Context, arg ListTokensParams) ([]TokensProjection, error) {
	rows, err := q.db.Query(ctx, listTokens, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TokensProjection{}
	for rows.Next() {
		var i TokensProjection
		if err := rows.Scan(
			&i.ID,
			&i.ValueHash,
			&i.Name,
			&i.OneTime,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Disabled,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTokensByOwner = `-- name: ListTokensByOwner :many
SELECT id, value_hash, name, one_time, max_uses, current_uses, expires_at, created_at, created_by, disabled, is_deleted, projection_version, owner_id FROM tokens_projection
WHERE is_deleted = FALSE
  AND owner_id = $1
  AND ($2::BOOLEAN OR disabled = FALSE)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListTokensByOwnerParams struct {
	OwnerID *string `json:"owner_id"`
	Column2 bool    `json:"column_2"`
	Limit   int32   `json:"limit"`
	Offset  int32   `json:"offset"`
}

func (q *Queries) ListTokensByOwner(ctx context.Context, arg ListTokensByOwnerParams) ([]TokensProjection, error) {
	rows, err := q.db.Query(ctx, listTokensByOwner,
		arg.OwnerID,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TokensProjection{}
	for rows.Next() {
		var i TokensProjection
		if err := rows.Scan(
			&i.ID,
			&i.ValueHash,
			&i.Name,
			&i.OneTime,
			&i.MaxUses,
			&i.CurrentUses,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Disabled,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
