// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: device_groups.sql

package generated

import (
	"context"
)

const countDeviceGroups = `-- name: CountDeviceGroups :one
SELECT COUNT(*) FROM device_groups_projection
WHERE is_deleted = FALSE
`

func (q *Queries) CountDeviceGroups(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countDeviceGroups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMatchingDevicesForQuery = `-- name: CountMatchingDevicesForQuery :one
SELECT COUNT(*) FROM devices_projection
WHERE is_deleted = FALSE
AND evaluate_dynamic_query_v2(id, labels, $1) = TRUE
`

func (q *Queries) CountMatchingDevicesForQuery(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, countMatchingDevicesForQuery, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const evaluateDynamicGroup = `-- name: EvaluateDynamicGroup :exec
SELECT evaluate_dynamic_group($1)
`

func (q *Queries) EvaluateDynamicGroup(ctx context.Context, groupIDParam string) error {
	_, err := q.db.Exec(ctx, evaluateDynamicGroup, groupIDParam)
	return err
}

const evaluateQueuedDynamicGroups = `-- name: EvaluateQueuedDynamicGroups :one
SELECT evaluate_queued_dynamic_groups() AS evaluated_count
`

func (q *Queries) EvaluateQueuedDynamicGroups(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, evaluateQueuedDynamicGroups)
	var evaluated_count int32
	err := row.Scan(&evaluated_count)
	return evaluated_count, err
}

const getDeviceGroupByID = `-- name: GetDeviceGroupByID :one

SELECT id, name, description, member_count, created_at, created_by, is_deleted, projection_version, is_dynamic, dynamic_query, sync_interval_minutes FROM device_groups_projection
WHERE id = $1 AND is_deleted = FALSE
`

// Device Groups queries
func (q *Queries) GetDeviceGroupByID(ctx context.Context, id string) (DeviceGroupsProjection, error) {
	row := q.db.QueryRow(ctx, getDeviceGroupByID, id)
	var i DeviceGroupsProjection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberCount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.IsDeleted,
		&i.ProjectionVersion,
		&i.IsDynamic,
		&i.DynamicQuery,
		&i.SyncIntervalMinutes,
	)
	return i, err
}

const getDeviceGroupByName = `-- name: GetDeviceGroupByName :one
SELECT id, name, description, member_count, created_at, created_by, is_deleted, projection_version, is_dynamic, dynamic_query, sync_interval_minutes FROM device_groups_projection
WHERE name = $1 AND is_deleted = FALSE
`

func (q *Queries) GetDeviceGroupByName(ctx context.Context, name string) (DeviceGroupsProjection, error) {
	row := q.db.QueryRow(ctx, getDeviceGroupByName, name)
	var i DeviceGroupsProjection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberCount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.IsDeleted,
		&i.ProjectionVersion,
		&i.IsDynamic,
		&i.DynamicQuery,
		&i.SyncIntervalMinutes,
	)
	return i, err
}

const getDeviceGroupMember = `-- name: GetDeviceGroupMember :one
SELECT group_id, device_id, added_at, projection_version FROM device_group_members_projection
WHERE group_id = $1 AND device_id = $2
`

type GetDeviceGroupMemberParams struct {
	GroupID  string `json:"group_id"`
	DeviceID string `json:"device_id"`
}

func (q *Queries) GetDeviceGroupMember(ctx context.Context, arg GetDeviceGroupMemberParams) (DeviceGroupMembersProjection, error) {
	row := q.db.QueryRow(ctx, getDeviceGroupMember, arg.GroupID, arg.DeviceID)
	var i DeviceGroupMembersProjection
	err := row.Scan(
		&i.GroupID,
		&i.DeviceID,
		&i.AddedAt,
		&i.ProjectionVersion,
	)
	return i, err
}

const getDynamicGroupsNeedingEvaluation = `-- name: GetDynamicGroupsNeedingEvaluation :many
SELECT g.id, g.name, g.description, g.member_count, g.created_at, g.created_by, g.is_deleted, g.projection_version, g.is_dynamic, g.dynamic_query, g.sync_interval_minutes FROM device_groups_projection g
JOIN dynamic_group_evaluation_queue q ON g.id = q.group_id
WHERE g.is_deleted = FALSE
ORDER BY q.queued_at ASC
LIMIT $1
`

func (q *Queries) GetDynamicGroupsNeedingEvaluation(ctx context.Context, limit int32) ([]DeviceGroupsProjection, error) {
	rows, err := q.db.Query(ctx, getDynamicGroupsNeedingEvaluation, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceGroupsProjection{}
	for rows.Next() {
		var i DeviceGroupsProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberCount,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.IsDynamic,
			&i.DynamicQuery,
			&i.SyncIntervalMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeviceGroupMembers = `-- name: ListDeviceGroupMembers :many

SELECT group_id, device_id, added_at, projection_version FROM device_group_members_projection
WHERE group_id = $1
ORDER BY added_at ASC
`

// Device Group Members queries
func (q *Queries) ListDeviceGroupMembers(ctx context.Context, groupID string) ([]DeviceGroupMembersProjection, error) {
	rows, err := q.db.Query(ctx, listDeviceGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceGroupMembersProjection{}
	for rows.Next() {
		var i DeviceGroupMembersProjection
		if err := rows.Scan(
			&i.GroupID,
			&i.DeviceID,
			&i.AddedAt,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeviceGroups = `-- name: ListDeviceGroups :many
SELECT id, name, description, member_count, created_at, created_by, is_deleted, projection_version, is_dynamic, dynamic_query, sync_interval_minutes FROM device_groups_projection
WHERE is_deleted = FALSE
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListDeviceGroupsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListDeviceGroups(ctx context.Context, arg ListDeviceGroupsParams) ([]DeviceGroupsProjection, error) {
	rows, err := q.db.Query(ctx, listDeviceGroups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceGroupsProjection{}
	for rows.Next() {
		var i DeviceGroupsProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberCount,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.IsDynamic,
			&i.DynamicQuery,
			&i.SyncIntervalMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDevicesInGroup = `-- name: ListDevicesInGroup :many
SELECT d.id, d.hostname, d.agent_version, d.cert_fingerprint, d.cert_not_after, d.registered_at, d.last_seen_at, d.registration_token_id, d.labels, d.is_deleted, d.projection_version, d.assigned_user_id, d.sync_interval_minutes FROM devices_projection d
JOIN device_group_members_projection m ON d.id = m.device_id
WHERE m.group_id = $1 AND d.is_deleted = FALSE
ORDER BY d.hostname ASC
`

func (q *Queries) ListDevicesInGroup(ctx context.Context, groupID string) ([]DevicesProjection, error) {
	rows, err := q.db.Query(ctx, listDevicesInGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DevicesProjection{}
	for rows.Next() {
		var i DevicesProjection
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.AgentVersion,
			&i.CertFingerprint,
			&i.CertNotAfter,
			&i.RegisteredAt,
			&i.LastSeenAt,
			&i.RegistrationTokenID,
			&i.Labels,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.AssignedUserID,
			&i.SyncIntervalMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDynamicDeviceGroups = `-- name: ListDynamicDeviceGroups :many

SELECT id, name, description, member_count, created_at, created_by, is_deleted, projection_version, is_dynamic, dynamic_query, sync_interval_minutes FROM device_groups_projection
WHERE is_dynamic = TRUE AND is_deleted = FALSE
ORDER BY created_at DESC
`

// Dynamic Group queries
func (q *Queries) ListDynamicDeviceGroups(ctx context.Context) ([]DeviceGroupsProjection, error) {
	rows, err := q.db.Query(ctx, listDynamicDeviceGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceGroupsProjection{}
	for rows.Next() {
		var i DeviceGroupsProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberCount,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.IsDynamic,
			&i.DynamicQuery,
			&i.SyncIntervalMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsForDevice = `-- name: ListGroupsForDevice :many
SELECT g.id, g.name, g.description, g.member_count, g.created_at, g.created_by, g.is_deleted, g.projection_version, g.is_dynamic, g.dynamic_query, g.sync_interval_minutes FROM device_groups_projection g
JOIN device_group_members_projection m ON g.id = m.group_id
WHERE m.device_id = $1 AND g.is_deleted = FALSE
ORDER BY g.name ASC
`

func (q *Queries) ListGroupsForDevice(ctx context.Context, deviceID string) ([]DeviceGroupsProjection, error) {
	rows, err := q.db.Query(ctx, listGroupsForDevice, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceGroupsProjection{}
	for rows.Next() {
		var i DeviceGroupsProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberCount,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.IsDynamic,
			&i.DynamicQuery,
			&i.SyncIntervalMinutes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const validateDynamicQuery = `-- name: ValidateDynamicQuery :one
SELECT COALESCE(validate_dynamic_query($1), '')::TEXT AS error_message
`

func (q *Queries) ValidateDynamicQuery(ctx context.Context, query string) (string, error) {
	row := q.db.QueryRow(ctx, validateDynamicQuery, query)
	var error_message string
	err := row.Scan(&error_message)
	return error_message, err
}
