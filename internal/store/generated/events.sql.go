// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package generated

import (
	"context"
)

const appendEvent = `-- name: AppendEvent :one
INSERT INTO events (
    stream_type, stream_id, stream_version,
    event_type, data, metadata,
    actor_type, actor_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at
`

type AppendEventParams struct {
	StreamType    string `json:"stream_type"`
	StreamID      string `json:"stream_id"`
	StreamVersion int32  `json:"stream_version"`
	EventType     string `json:"event_type"`
	Data          []byte `json:"data"`
	Metadata      []byte `json:"metadata"`
	ActorType     string `json:"actor_type"`
	ActorID       string `json:"actor_id"`
}

func (q *Queries) AppendEvent(ctx context.Context, arg AppendEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, appendEvent,
		arg.StreamType,
		arg.StreamID,
		arg.StreamVersion,
		arg.EventType,
		arg.Data,
		arg.Metadata,
		arg.ActorType,
		arg.ActorID,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.SequenceNum,
		&i.StreamType,
		&i.StreamID,
		&i.StreamVersion,
		&i.EventType,
		&i.Data,
		&i.Metadata,
		&i.ActorType,
		&i.ActorID,
		&i.OccurredAt,
	)
	return i, err
}

const countAuditEvents = `-- name: CountAuditEvents :one
SELECT COUNT(*) FROM events
WHERE ($1::TEXT = '' OR actor_id = $1)
  AND ($2::TEXT = '' OR stream_type = $2)
  AND ($3::TEXT = '' OR event_type = $3)
`

type CountAuditEventsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
}

func (q *Queries) CountAuditEvents(ctx context.Context, arg CountAuditEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAuditEvents, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countEventsByStreamType = `-- name: CountEventsByStreamType :one
SELECT COUNT(*) FROM events
WHERE stream_type = $1
`

func (q *Queries) CountEventsByStreamType(ctx context.Context, streamType string) (int64, error) {
	row := q.db.QueryRow(ctx, countEventsByStreamType, streamType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getLatestSequence = `-- name: GetLatestSequence :one
SELECT COALESCE(MAX(sequence_num), 0)::BIGINT as sequence_num FROM events
`

func (q *Queries) GetLatestSequence(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestSequence)
	var sequence_num int64
	err := row.Scan(&sequence_num)
	return sequence_num, err
}

const getStreamVersion = `-- name: GetStreamVersion :one
SELECT COALESCE(MAX(stream_version), 0)::INTEGER as version
FROM events
WHERE stream_type = $1 AND stream_id = $2
`

type GetStreamVersionParams struct {
	StreamType string `json:"stream_type"`
	StreamID   string `json:"stream_id"`
}

func (q *Queries) GetStreamVersion(ctx context.Context, arg GetStreamVersionParams) (int32, error) {
	row := q.db.QueryRow(ctx, getStreamVersion, arg.StreamType, arg.StreamID)
	var version int32
	err := row.Scan(&version)
	return version, err
}

const listAuditEvents = `-- name: ListAuditEvents :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE ($1::TEXT = '' OR actor_id = $1)
  AND ($2::TEXT = '' OR stream_type = $2)
  AND ($3::TEXT = '' OR event_type = $3)
ORDER BY occurred_at DESC
LIMIT $4 OFFSET $5
`

type ListAuditEventsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListAuditEvents(ctx context.Context, arg ListAuditEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, listAuditEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadAllEvents = `-- name: LoadAllEvents :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE sequence_num > $1
ORDER BY sequence_num
LIMIT $2
`

type LoadAllEventsParams struct {
	SequenceNum *int64 `json:"sequence_num"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) LoadAllEvents(ctx context.Context, arg LoadAllEventsParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, loadAllEvents, arg.SequenceNum, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadEventsByActor = `-- name: LoadEventsByActor :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE actor_type = $1 AND actor_id = $2
ORDER BY occurred_at DESC
LIMIT $3 OFFSET $4
`

type LoadEventsByActorParams struct {
	ActorType string `json:"actor_type"`
	ActorID   string `json:"actor_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) LoadEventsByActor(ctx context.Context, arg LoadEventsByActorParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, loadEventsByActor,
		arg.ActorType,
		arg.ActorID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadEventsByStreamType = `-- name: LoadEventsByStreamType :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE stream_type = $1
ORDER BY sequence_num DESC
LIMIT $2 OFFSET $3
`

type LoadEventsByStreamTypeParams struct {
	StreamType string `json:"stream_type"`
	Limit      int32  `json:"limit"`
	Offset     int32  `json:"offset"`
}

func (q *Queries) LoadEventsByStreamType(ctx context.Context, arg LoadEventsByStreamTypeParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, loadEventsByStreamType, arg.StreamType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadEventsByType = `-- name: LoadEventsByType :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE event_type = $1
ORDER BY sequence_num DESC
LIMIT $2 OFFSET $3
`

type LoadEventsByTypeParams struct {
	EventType string `json:"event_type"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) LoadEventsByType(ctx context.Context, arg LoadEventsByTypeParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, loadEventsByType, arg.EventType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadOutputChunks = `-- name: LoadOutputChunks :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE stream_type = 'execution'
  AND stream_id = $1
  AND event_type = 'OutputChunk'
ORDER BY stream_version
`

// Load all output chunks for an execution, ordered by sequence
func (q *Queries) LoadOutputChunks(ctx context.Context, streamID string) ([]Event, error) {
	rows, err := q.db.Query(ctx, loadOutputChunks, streamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadStream = `-- name: LoadStream :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE stream_type = $1 AND stream_id = $2
ORDER BY stream_version
`

type LoadStreamParams struct {
	StreamType string `json:"stream_type"`
	StreamID   string `json:"stream_id"`
}

func (q *Queries) LoadStream(ctx context.Context, arg LoadStreamParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, loadStream, arg.StreamType, arg.StreamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const loadStreamFromVersion = `-- name: LoadStreamFromVersion :many
SELECT id, sequence_num, stream_type, stream_id, stream_version, event_type, data, metadata, actor_type, actor_id, occurred_at FROM events
WHERE stream_type = $1 AND stream_id = $2 AND stream_version > $3
ORDER BY stream_version
`

type LoadStreamFromVersionParams struct {
	StreamType    string `json:"stream_type"`
	StreamID      string `json:"stream_id"`
	StreamVersion int32  `json:"stream_version"`
}

func (q *Queries) LoadStreamFromVersion(ctx context.Context, arg LoadStreamFromVersionParams) ([]Event, error) {
	rows, err := q.db.Query(ctx, loadStreamFromVersion, arg.StreamType, arg.StreamID, arg.StreamVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Event{}
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.SequenceNum,
			&i.StreamType,
			&i.StreamID,
			&i.StreamVersion,
			&i.EventType,
			&i.Data,
			&i.Metadata,
			&i.ActorType,
			&i.ActorID,
			&i.OccurredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
