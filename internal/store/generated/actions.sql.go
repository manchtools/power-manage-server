// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: actions.sql

package generated

import (
	"context"
)

const countActions = `-- name: CountActions :one
SELECT COUNT(*) FROM actions_projection
WHERE is_deleted = FALSE
  AND ($1::INTEGER = 0 OR action_type = $1)
`

func (q *Queries) CountActions(ctx context.Context, dollar_1 int32) (int64, error) {
	row := q.db.QueryRow(ctx, countActions, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExecutions = `-- name: CountExecutions :one
SELECT COUNT(*) FROM executions_projection
WHERE ($1::TEXT = '' OR device_id = $1)
  AND ($2::TEXT = '' OR status = $2)
`

type CountExecutionsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
}

func (q *Queries) CountExecutions(ctx context.Context, arg CountExecutionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countExecutions, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getActionByID = `-- name: GetActionByID :one

SELECT id, name, description, action_type, params, timeout_seconds, created_at, created_by, is_deleted, projection_version, signature, params_canonical, desired_state FROM actions_projection
WHERE id = $1 AND is_deleted = FALSE
`

// Actions queries (renamed from definitions)
func (q *Queries) GetActionByID(ctx context.Context, id string) (ActionsProjection, error) {
	row := q.db.QueryRow(ctx, getActionByID, id)
	var i ActionsProjection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ActionType,
		&i.Params,
		&i.TimeoutSeconds,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.IsDeleted,
		&i.ProjectionVersion,
		&i.Signature,
		&i.ParamsCanonical,
		&i.DesiredState,
	)
	return i, err
}

const getActionByName = `-- name: GetActionByName :one
SELECT id, name, description, action_type, params, timeout_seconds, created_at, created_by, is_deleted, projection_version, signature, params_canonical, desired_state FROM actions_projection
WHERE name = $1 AND is_deleted = FALSE
`

func (q *Queries) GetActionByName(ctx context.Context, name string) (ActionsProjection, error) {
	row := q.db.QueryRow(ctx, getActionByName, name)
	var i ActionsProjection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ActionType,
		&i.Params,
		&i.TimeoutSeconds,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.IsDeleted,
		&i.ProjectionVersion,
		&i.Signature,
		&i.ParamsCanonical,
		&i.DesiredState,
	)
	return i, err
}

const getExecutionByID = `-- name: GetExecutionByID :one

SELECT id, device_id, action_id, action_type, desired_state, params, timeout_seconds, status, error, output, created_at, dispatched_at, started_at, completed_at, duration_ms, created_by_type, created_by_id, projection_version, changed FROM executions_projection
WHERE id = $1
`

// Executions queries
func (q *Queries) GetExecutionByID(ctx context.Context, id string) (ExecutionsProjection, error) {
	row := q.db.QueryRow(ctx, getExecutionByID, id)
	var i ExecutionsProjection
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.ActionID,
		&i.ActionType,
		&i.DesiredState,
		&i.Params,
		&i.TimeoutSeconds,
		&i.Status,
		&i.Error,
		&i.Output,
		&i.CreatedAt,
		&i.DispatchedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.DurationMs,
		&i.CreatedByType,
		&i.CreatedByID,
		&i.ProjectionVersion,
		&i.Changed,
	)
	return i, err
}

const listActions = `-- name: ListActions :many
SELECT id, name, description, action_type, params, timeout_seconds, created_at, created_by, is_deleted, projection_version, signature, params_canonical, desired_state FROM actions_projection
WHERE is_deleted = FALSE
  AND ($1::INTEGER = 0 OR action_type = $1)
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListActionsParams struct {
	Column1 int32 `json:"column_1"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListActions(ctx context.Context, arg ListActionsParams) ([]ActionsProjection, error) {
	rows, err := q.db.Query(ctx, listActions, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ActionsProjection{}
	for rows.Next() {
		var i ActionsProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ActionType,
			&i.Params,
			&i.TimeoutSeconds,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.Signature,
			&i.ParamsCanonical,
			&i.DesiredState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExecutions = `-- name: ListExecutions :many
SELECT id, device_id, action_id, action_type, desired_state, params, timeout_seconds, status, error, output, created_at, dispatched_at, started_at, completed_at, duration_ms, created_by_type, created_by_id, projection_version, changed FROM executions_projection
WHERE ($1::TEXT = '' OR device_id = $1)
  AND ($2::TEXT = '' OR status = $2)
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListExecutionsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListExecutions(ctx context.Context, arg ListExecutionsParams) ([]ExecutionsProjection, error) {
	rows, err := q.db.Query(ctx, listExecutions,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExecutionsProjection{}
	for rows.Next() {
		var i ExecutionsProjection
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.ActionID,
			&i.ActionType,
			&i.DesiredState,
			&i.Params,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Error,
			&i.Output,
			&i.CreatedAt,
			&i.DispatchedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.CreatedByType,
			&i.CreatedByID,
			&i.ProjectionVersion,
			&i.Changed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingExecutionsForDevice = `-- name: ListPendingExecutionsForDevice :many
SELECT id, device_id, action_id, action_type, desired_state, params, timeout_seconds, status, error, output, created_at, dispatched_at, started_at, completed_at, duration_ms, created_by_type, created_by_id, projection_version, changed FROM executions_projection
WHERE device_id = $1 AND status IN ('pending', 'dispatched')
ORDER BY created_at ASC
`

// Include both 'pending' and 'dispatched' statuses, since dispatched executions
// may need to be re-sent if the agent disconnected before receiving them
func (q *Queries) ListPendingExecutionsForDevice(ctx context.Context, deviceID string) ([]ExecutionsProjection, error) {
	rows, err := q.db.Query(ctx, listPendingExecutionsForDevice, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExecutionsProjection{}
	for rows.Next() {
		var i ExecutionsProjection
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.ActionID,
			&i.ActionType,
			&i.DesiredState,
			&i.Params,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Error,
			&i.Output,
			&i.CreatedAt,
			&i.DispatchedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.CreatedByType,
			&i.CreatedByID,
			&i.ProjectionVersion,
			&i.Changed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentExecutionsForDevice = `-- name: ListRecentExecutionsForDevice :many
SELECT id, device_id, action_id, action_type, desired_state, params, timeout_seconds, status, error, output, created_at, dispatched_at, started_at, completed_at, duration_ms, created_by_type, created_by_id, projection_version, changed FROM executions_projection
WHERE device_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListRecentExecutionsForDeviceParams struct {
	DeviceID string `json:"device_id"`
	Limit    int32  `json:"limit"`
}

func (q *Queries) ListRecentExecutionsForDevice(ctx context.Context, arg ListRecentExecutionsForDeviceParams) ([]ExecutionsProjection, error) {
	rows, err := q.db.Query(ctx, listRecentExecutionsForDevice, arg.DeviceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ExecutionsProjection{}
	for rows.Next() {
		var i ExecutionsProjection
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.ActionID,
			&i.ActionType,
			&i.DesiredState,
			&i.Params,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Error,
			&i.Output,
			&i.CreatedAt,
			&i.DispatchedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.DurationMs,
			&i.CreatedByType,
			&i.CreatedByID,
			&i.ProjectionVersion,
			&i.Changed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateActionSignature = `-- name: UpdateActionSignature :exec
UPDATE actions_projection
SET signature = $2, params_canonical = $3
WHERE id = $1
`

type UpdateActionSignatureParams struct {
	ID              string `json:"id"`
	Signature       []byte `json:"signature"`
	ParamsCanonical []byte `json:"params_canonical"`
}

func (q *Queries) UpdateActionSignature(ctx context.Context, arg UpdateActionSignatureParams) error {
	_, err := q.db.Exec(ctx, updateActionSignature, arg.ID, arg.Signature, arg.ParamsCanonical)
	return err
}
