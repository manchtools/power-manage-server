// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: assignments.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAssignments = `-- name: CountAssignments :one
SELECT COUNT(*) FROM assignments_projection
WHERE is_deleted = FALSE
  AND ($1::TEXT = '' OR source_type = $1)
  AND ($2::TEXT = '' OR source_id = $2)
  AND ($3::TEXT = '' OR target_type = $3)
  AND ($4::TEXT = '' OR target_id = $4)
`

type CountAssignmentsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Column4 string `json:"column_4"`
}

func (q *Queries) CountAssignments(ctx context.Context, arg CountAssignmentsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countAssignments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAssignment = `-- name: GetAssignment :one
SELECT id, source_type, source_id, target_type, target_id, sort_order, mode, created_at, created_by, is_deleted, projection_version FROM assignments_projection
WHERE source_type = $1 AND source_id = $2 AND target_type = $3 AND target_id = $4 AND is_deleted = FALSE
`

type GetAssignmentParams struct {
	SourceType string `json:"source_type"`
	SourceID   string `json:"source_id"`
	TargetType string `json:"target_type"`
	TargetID   string `json:"target_id"`
}

func (q *Queries) GetAssignment(ctx context.Context, arg GetAssignmentParams) (AssignmentsProjection, error) {
	row := q.db.QueryRow(ctx, getAssignment,
		arg.SourceType,
		arg.SourceID,
		arg.TargetType,
		arg.TargetID,
	)
	var i AssignmentsProjection
	err := row.Scan(
		&i.ID,
		&i.SourceType,
		&i.SourceID,
		&i.TargetType,
		&i.TargetID,
		&i.SortOrder,
		&i.Mode,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.IsDeleted,
		&i.ProjectionVersion,
	)
	return i, err
}

const getAssignmentByID = `-- name: GetAssignmentByID :one

SELECT id, source_type, source_id, target_type, target_id, sort_order, mode, created_at, created_by, is_deleted, projection_version FROM assignments_projection
WHERE id = $1 AND is_deleted = FALSE
`

// Assignments queries
func (q *Queries) GetAssignmentByID(ctx context.Context, id string) (AssignmentsProjection, error) {
	row := q.db.QueryRow(ctx, getAssignmentByID, id)
	var i AssignmentsProjection
	err := row.Scan(
		&i.ID,
		&i.SourceType,
		&i.SourceID,
		&i.TargetType,
		&i.TargetID,
		&i.SortOrder,
		&i.Mode,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.IsDeleted,
		&i.ProjectionVersion,
	)
	return i, err
}

const listAssignedActionsForDevice = `-- name: ListAssignedActionsForDevice :many
WITH assigned_actions AS (
  -- Direct action assignments (no hierarchy, use assignment sort_order only)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds, a.created_at, a.created_by, a.is_deleted, a.projection_version, a.signature, a.params_canonical,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    0 as action_set_sort,
    0 as action_sort
  FROM actions_projection a
  JOIN assignments_projection asn ON asn.source_type = 'action' AND asn.source_id = a.id
  WHERE asn.target_type = 'device' AND asn.target_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Action assignments via device group
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds, a.created_at, a.created_by, a.is_deleted, a.projection_version, a.signature, a.params_canonical,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    0 as action_set_sort,
    0 as action_sort
  FROM actions_projection a
  JOIN assignments_projection asn ON asn.source_type = 'action' AND asn.source_id = a.id
  JOIN device_group_members_projection m ON asn.target_id = m.group_id
  WHERE asn.target_type = 'device_group' AND m.device_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via action set assignments (direct to device)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds, a.created_at, a.created_by, a.is_deleted, a.projection_version, a.signature, a.params_canonical,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN assignments_projection asn ON asn.source_type = 'action_set' AND asn.source_id = sm.set_id
  WHERE asn.target_type = 'device' AND asn.target_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via action set assignments (via device group)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds, a.created_at, a.created_by, a.is_deleted, a.projection_version, a.signature, a.params_canonical,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN assignments_projection asn ON asn.source_type = 'action_set' AND asn.source_id = sm.set_id
  JOIN device_group_members_projection m ON asn.target_id = m.group_id
  WHERE asn.target_type = 'device_group' AND m.device_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via definition assignments (direct to device)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds, a.created_at, a.created_by, a.is_deleted, a.projection_version, a.signature, a.params_canonical,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    COALESCE(dm.sort_order, 0) as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN definition_members_projection dm ON dm.action_set_id = sm.set_id
  JOIN assignments_projection asn ON asn.source_type = 'definition' AND asn.source_id = dm.definition_id
  WHERE asn.target_type = 'device' AND asn.target_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via definition assignments (via device group)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds, a.created_at, a.created_by, a.is_deleted, a.projection_version, a.signature, a.params_canonical,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    COALESCE(dm.sort_order, 0) as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN definition_members_projection dm ON dm.action_set_id = sm.set_id
  JOIN assignments_projection asn ON asn.source_type = 'definition' AND asn.source_id = dm.definition_id
  JOIN device_group_members_projection m ON asn.target_id = m.group_id
  WHERE asn.target_type = 'device_group' AND m.device_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE
),
deduped AS (
  SELECT DISTINCT ON (id)
    id, name, description, action_type, params, timeout_seconds,
    created_at, created_by, is_deleted, projection_version, signature, params_canonical,
    assignment_sort, definition_sort, action_set_sort, action_sort
  FROM assigned_actions
  ORDER BY id, assignment_sort, definition_sort, action_set_sort, action_sort
)
SELECT id, name, description, action_type, params, timeout_seconds,
       created_at, created_by, is_deleted, projection_version, signature, params_canonical
FROM deduped
ORDER BY assignment_sort, definition_sort, action_set_sort, action_sort, id
`

type ListAssignedActionsForDeviceRow struct {
	ID                string             `json:"id"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	ActionType        int32              `json:"action_type"`
	Params            []byte             `json:"params"`
	TimeoutSeconds    int32              `json:"timeout_seconds"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	CreatedBy         string             `json:"created_by"`
	IsDeleted         bool               `json:"is_deleted"`
	ProjectionVersion int64              `json:"projection_version"`
	Signature         []byte             `json:"signature"`
	ParamsCanonical   []byte             `json:"params_canonical"`
}

// Get all actions assigned to a device (directly or via groups) with proper ordering
// Actions are ordered by: assignment_sort_order, definition_sort_order, action_set_sort_order, action_sort_order
// This ensures actions from definitions run in the correct sequence
// First deduplicate by taking the lowest sort order for each action
// Then return in the correct execution order
func (q *Queries) ListAssignedActionsForDevice(ctx context.Context, targetID string) ([]ListAssignedActionsForDeviceRow, error) {
	rows, err := q.db.Query(ctx, listAssignedActionsForDevice, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAssignedActionsForDeviceRow{}
	for rows.Next() {
		var i ListAssignedActionsForDeviceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ActionType,
			&i.Params,
			&i.TimeoutSeconds,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.Signature,
			&i.ParamsCanonical,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignments = `-- name: ListAssignments :many
SELECT id, source_type, source_id, target_type, target_id, sort_order, mode, created_at, created_by, is_deleted, projection_version FROM assignments_projection
WHERE is_deleted = FALSE
  AND ($1::TEXT = '' OR source_type = $1)
  AND ($2::TEXT = '' OR source_id = $2)
  AND ($3::TEXT = '' OR target_type = $3)
  AND ($4::TEXT = '' OR target_id = $4)
ORDER BY created_at DESC
LIMIT $5 OFFSET $6
`

type ListAssignmentsParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Column4 string `json:"column_4"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListAssignments(ctx context.Context, arg ListAssignmentsParams) ([]AssignmentsProjection, error) {
	rows, err := q.db.Query(ctx, listAssignments,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssignmentsProjection{}
	for rows.Next() {
		var i AssignmentsProjection
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.TargetType,
			&i.TargetID,
			&i.SortOrder,
			&i.Mode,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsForSource = `-- name: ListAssignmentsForSource :many
SELECT id, source_type, source_id, target_type, target_id, sort_order, mode, created_at, created_by, is_deleted, projection_version FROM assignments_projection
WHERE source_type = $1 AND source_id = $2 AND is_deleted = FALSE
ORDER BY created_at DESC
`

type ListAssignmentsForSourceParams struct {
	SourceType string `json:"source_type"`
	SourceID   string `json:"source_id"`
}

// Get all assignments for a specific source
func (q *Queries) ListAssignmentsForSource(ctx context.Context, arg ListAssignmentsForSourceParams) ([]AssignmentsProjection, error) {
	rows, err := q.db.Query(ctx, listAssignmentsForSource, arg.SourceType, arg.SourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssignmentsProjection{}
	for rows.Next() {
		var i AssignmentsProjection
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.TargetType,
			&i.TargetID,
			&i.SortOrder,
			&i.Mode,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAssignmentsForTarget = `-- name: ListAssignmentsForTarget :many
SELECT id, source_type, source_id, target_type, target_id, sort_order, mode, created_at, created_by, is_deleted, projection_version FROM assignments_projection
WHERE target_type = $1 AND target_id = $2 AND is_deleted = FALSE
ORDER BY created_at DESC
`

type ListAssignmentsForTargetParams struct {
	TargetType string `json:"target_type"`
	TargetID   string `json:"target_id"`
}

// Get all assignments for a specific target
func (q *Queries) ListAssignmentsForTarget(ctx context.Context, arg ListAssignmentsForTargetParams) ([]AssignmentsProjection, error) {
	rows, err := q.db.Query(ctx, listAssignmentsForTarget, arg.TargetType, arg.TargetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssignmentsProjection{}
	for rows.Next() {
		var i AssignmentsProjection
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.TargetType,
			&i.TargetID,
			&i.SortOrder,
			&i.Mode,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDirectAssignmentsForDevice = `-- name: ListDirectAssignmentsForDevice :many
SELECT id, source_type, source_id, target_type, target_id, sort_order, mode, created_at, created_by, is_deleted, projection_version FROM assignments_projection
WHERE target_type = 'device' AND target_id = $1 AND is_deleted = FALSE
ORDER BY created_at DESC
`

// Get all direct assignments for a device (not including group memberships)
func (q *Queries) ListDirectAssignmentsForDevice(ctx context.Context, targetID string) ([]AssignmentsProjection, error) {
	rows, err := q.db.Query(ctx, listDirectAssignmentsForDevice, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssignmentsProjection{}
	for rows.Next() {
		var i AssignmentsProjection
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.TargetType,
			&i.TargetID,
			&i.SortOrder,
			&i.Mode,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupAssignmentsForDevice = `-- name: ListGroupAssignmentsForDevice :many
SELECT a.id, a.source_type, a.source_id, a.target_type, a.target_id, a.sort_order, a.mode, a.created_at, a.created_by, a.is_deleted, a.projection_version FROM assignments_projection a
JOIN device_group_members_projection m ON a.target_id = m.group_id
WHERE a.target_type = 'device_group'
  AND m.device_id = $1
  AND a.is_deleted = FALSE
ORDER BY a.created_at DESC
`

// Get all assignments for device groups the device belongs to
func (q *Queries) ListGroupAssignmentsForDevice(ctx context.Context, deviceID string) ([]AssignmentsProjection, error) {
	rows, err := q.db.Query(ctx, listGroupAssignmentsForDevice, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AssignmentsProjection{}
	for rows.Next() {
		var i AssignmentsProjection
		if err := rows.Scan(
			&i.ID,
			&i.SourceType,
			&i.SourceID,
			&i.TargetType,
			&i.TargetID,
			&i.SortOrder,
			&i.Mode,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResolvedActionsForDevice = `-- name: ListResolvedActionsForDevice :many
WITH all_assignments AS (
  -- Direct action assignments
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds,
    a.created_at, a.created_by, a.is_deleted, a.projection_version,
    a.signature, a.params_canonical,
    asn.mode,
    asn.source_type AS asn_source_type,
    asn.source_id AS asn_source_id,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    0 as action_set_sort,
    0 as action_sort
  FROM actions_projection a
  JOIN assignments_projection asn ON asn.source_type = 'action' AND asn.source_id = a.id
  WHERE asn.target_type = 'device' AND asn.target_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Action assignments via device group
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds,
    a.created_at, a.created_by, a.is_deleted, a.projection_version,
    a.signature, a.params_canonical,
    asn.mode,
    asn.source_type AS asn_source_type,
    asn.source_id AS asn_source_id,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    0 as action_set_sort,
    0 as action_sort
  FROM actions_projection a
  JOIN assignments_projection asn ON asn.source_type = 'action' AND asn.source_id = a.id
  JOIN device_group_members_projection m ON asn.target_id = m.group_id
  WHERE asn.target_type = 'device_group' AND m.device_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via action set assignments (direct to device)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds,
    a.created_at, a.created_by, a.is_deleted, a.projection_version,
    a.signature, a.params_canonical,
    asn.mode,
    asn.source_type AS asn_source_type,
    asn.source_id AS asn_source_id,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN assignments_projection asn ON asn.source_type = 'action_set' AND asn.source_id = sm.set_id
  WHERE asn.target_type = 'device' AND asn.target_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via action set assignments (via device group)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds,
    a.created_at, a.created_by, a.is_deleted, a.projection_version,
    a.signature, a.params_canonical,
    asn.mode,
    asn.source_type AS asn_source_type,
    asn.source_id AS asn_source_id,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    0 as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN assignments_projection asn ON asn.source_type = 'action_set' AND asn.source_id = sm.set_id
  JOIN device_group_members_projection m ON asn.target_id = m.group_id
  WHERE asn.target_type = 'device_group' AND m.device_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via definition assignments (direct to device)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds,
    a.created_at, a.created_by, a.is_deleted, a.projection_version,
    a.signature, a.params_canonical,
    asn.mode,
    asn.source_type AS asn_source_type,
    asn.source_id AS asn_source_id,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    COALESCE(dm.sort_order, 0) as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN definition_members_projection dm ON dm.action_set_id = sm.set_id
  JOIN assignments_projection asn ON asn.source_type = 'definition' AND asn.source_id = dm.definition_id
  WHERE asn.target_type = 'device' AND asn.target_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE

  UNION ALL

  -- Actions via definition assignments (via device group)
  SELECT
    a.id, a.name, a.description, a.action_type, a.params, a.timeout_seconds,
    a.created_at, a.created_by, a.is_deleted, a.projection_version,
    a.signature, a.params_canonical,
    asn.mode,
    asn.source_type AS asn_source_type,
    asn.source_id AS asn_source_id,
    COALESCE(asn.sort_order, 0) as assignment_sort,
    COALESCE(dm.sort_order, 0) as definition_sort,
    COALESCE(sm.sort_order, 0) as action_set_sort,
    COALESCE(sm.sort_order, 0) as action_sort
  FROM actions_projection a
  JOIN action_set_members_projection sm ON sm.action_id = a.id
  JOIN definition_members_projection dm ON dm.action_set_id = sm.set_id
  JOIN assignments_projection asn ON asn.source_type = 'definition' AND asn.source_id = dm.definition_id
  JOIN device_group_members_projection m ON asn.target_id = m.group_id
  WHERE asn.target_type = 'device_group' AND m.device_id = $1
    AND asn.is_deleted = FALSE AND a.is_deleted = FALSE
),
with_selections AS (
  SELECT aa.id, aa.name, aa.description, aa.action_type, aa.params, aa.timeout_seconds, aa.created_at, aa.created_by, aa.is_deleted, aa.projection_version, aa.signature, aa.params_canonical, aa.mode, aa.asn_source_type, aa.asn_source_id, aa.assignment_sort, aa.definition_sort, aa.action_set_sort, aa.action_sort,
    CASE WHEN aa.mode = 1 THEN us.selected ELSE NULL END AS user_selected
  FROM all_assignments aa
  LEFT JOIN user_selections_projection us
    ON us.device_id = $1
    AND us.source_type = aa.asn_source_type
    AND us.source_id = aa.asn_source_id
),
effective AS (
  SELECT
    id, name, description, action_type, params, timeout_seconds,
    created_at, created_by, is_deleted, projection_version,
    signature, params_canonical,
    CASE
      WHEN bool_or(mode = 2) THEN 2                            -- absent wins
      WHEN bool_or(mode = 0) THEN 0                            -- present wins
      WHEN bool_or(mode = 1 AND user_selected = TRUE) THEN 0   -- available+selected → present
      WHEN bool_or(mode = 1 AND user_selected = FALSE) THEN 2  -- available+rejected → absent
      ELSE -1                                                    -- unselected available → exclude
    END AS effective_mode,
    MIN(assignment_sort) AS assignment_sort,
    MIN(definition_sort) AS definition_sort,
    MIN(action_set_sort) AS action_set_sort,
    MIN(action_sort) AS action_sort
  FROM with_selections
  GROUP BY id, name, description, action_type, params, timeout_seconds,
           created_at, created_by, is_deleted, projection_version,
           signature, params_canonical
)
SELECT id, name, description, action_type,
  CASE WHEN effective_mode = 2 THEN 1 ELSE 0 END AS desired_state,
  params, timeout_seconds, created_at, created_by, is_deleted,
  projection_version, signature, params_canonical
FROM effective
WHERE effective_mode >= 0
ORDER BY assignment_sort, definition_sort, action_set_sort, action_sort, id
`

type ListResolvedActionsForDeviceRow struct {
	ID                string             `json:"id"`
	Name              string             `json:"name"`
	Description       *string            `json:"description"`
	ActionType        int32              `json:"action_type"`
	DesiredState      int32              `json:"desired_state"`
	Params            []byte             `json:"params"`
	TimeoutSeconds    int32              `json:"timeout_seconds"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	CreatedBy         string             `json:"created_by"`
	IsDeleted         bool               `json:"is_deleted"`
	ProjectionVersion int64              `json:"projection_version"`
	Signature         []byte             `json:"signature"`
	ParamsCanonical   []byte             `json:"params_canonical"`
}

// Get all resolved actions for a device with desired_state computed from assignment modes.
// This is used by the agent sync to determine what actions to apply and with what desired_state.
// Conflict resolution: absent (2) > present (0) > available+selected > available+rejected > unselected (excluded)
// Join with user selections for available assignments
// Resolve conflicts per action: absent > present > available+selected > available+rejected
// Return with computed desired_state: mode 2 (absent) → 1, mode 0 (present) → 0
func (q *Queries) ListResolvedActionsForDevice(ctx context.Context, targetID string) ([]ListResolvedActionsForDeviceRow, error) {
	rows, err := q.db.Query(ctx, listResolvedActionsForDevice, targetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListResolvedActionsForDeviceRow{}
	for rows.Next() {
		var i ListResolvedActionsForDeviceRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ActionType,
			&i.DesiredState,
			&i.Params,
			&i.TimeoutSeconds,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.IsDeleted,
			&i.ProjectionVersion,
			&i.Signature,
			&i.ParamsCanonical,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
