// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_groups.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countGroupsWithRole = `-- name: CountGroupsWithRole :one
SELECT count(*) FROM user_group_roles_projection WHERE role_id = $1
`

func (q *Queries) CountGroupsWithRole(ctx context.Context, roleID string) (int64, error) {
	row := q.db.QueryRow(ctx, countGroupsWithRole, roleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserGroups = `-- name: CountUserGroups :one
SELECT count(*) FROM user_groups_projection WHERE is_deleted = FALSE
`

func (q *Queries) CountUserGroups(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUserGroups)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserGroupByID = `-- name: GetUserGroupByID :one
SELECT id, name, description, member_count, created_at, created_by, updated_at, is_deleted, projection_version FROM user_groups_projection WHERE id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetUserGroupByID(ctx context.Context, id string) (UserGroupsProjection, error) {
	row := q.db.QueryRow(ctx, getUserGroupByID, id)
	var i UserGroupsProjection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberCount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.ProjectionVersion,
	)
	return i, err
}

const getUserGroupByName = `-- name: GetUserGroupByName :one
SELECT id, name, description, member_count, created_at, created_by, updated_at, is_deleted, projection_version FROM user_groups_projection WHERE name = $1 AND is_deleted = FALSE
`

func (q *Queries) GetUserGroupByName(ctx context.Context, name string) (UserGroupsProjection, error) {
	row := q.db.QueryRow(ctx, getUserGroupByName, name)
	var i UserGroupsProjection
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MemberCount,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.IsDeleted,
		&i.ProjectionVersion,
	)
	return i, err
}

const getUserGroupRoles = `-- name: GetUserGroupRoles :many
SELECT r.id, r.name, r.description, r.permissions, r.is_system, r.created_at, r.created_by, r.updated_at, r.is_deleted, r.projection_version FROM roles_projection r
JOIN user_group_roles_projection ugr ON ugr.role_id = r.id
WHERE ugr.group_id = $1 AND r.is_deleted = FALSE
ORDER BY r.name
`

func (q *Queries) GetUserGroupRoles(ctx context.Context, groupID string) ([]RolesProjection, error) {
	rows, err := q.db.Query(ctx, getUserGroupRoles, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RolesProjection{}
	for rows.Next() {
		var i RolesProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Permissions,
			&i.IsSystem,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissionsWithGroups = `-- name: GetUserPermissionsWithGroups :many
SELECT DISTINCT unnest(r.permissions)::TEXT AS permission
FROM roles_projection r
WHERE r.is_deleted = FALSE AND (
    r.id IN (SELECT ur.role_id FROM user_roles_projection ur WHERE ur.user_id = $1)
    OR
    r.id IN (
        SELECT ugr.role_id FROM user_group_roles_projection ugr
        JOIN user_group_members_projection ugm ON ugm.group_id = ugr.group_id
        WHERE ugm.user_id = $1
    )
)
`

func (q *Queries) GetUserPermissionsWithGroups(ctx context.Context, userID string) ([]string, error) {
	rows, err := q.db.Query(ctx, getUserPermissionsWithGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var permission string
		if err := rows.Scan(&permission); err != nil {
			return nil, err
		}
		items = append(items, permission)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserInGroup = `-- name: IsUserInGroup :one
SELECT EXISTS(
    SELECT 1 FROM user_group_members_projection
    WHERE group_id = $1 AND user_id = $2
) AS is_member
`

type IsUserInGroupParams struct {
	GroupID string `json:"group_id"`
	UserID  string `json:"user_id"`
}

func (q *Queries) IsUserInGroup(ctx context.Context, arg IsUserInGroupParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInGroup, arg.GroupID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const listUserGroupMemberIDs = `-- name: ListUserGroupMemberIDs :many
SELECT user_id FROM user_group_members_projection WHERE group_id = $1
`

func (q *Queries) ListUserGroupMemberIDs(ctx context.Context, groupID string) ([]string, error) {
	rows, err := q.db.Query(ctx, listUserGroupMemberIDs, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserGroupMembers = `-- name: ListUserGroupMembers :many
SELECT ugm.user_id, u.email, ugm.added_at
FROM user_group_members_projection ugm
JOIN users_projection u ON u.id = ugm.user_id AND u.is_deleted = FALSE
WHERE ugm.group_id = $1
ORDER BY ugm.added_at
`

type ListUserGroupMembersRow struct {
	UserID  string             `json:"user_id"`
	Email   string             `json:"email"`
	AddedAt pgtype.Timestamptz `json:"added_at"`
}

func (q *Queries) ListUserGroupMembers(ctx context.Context, groupID string) ([]ListUserGroupMembersRow, error) {
	rows, err := q.db.Query(ctx, listUserGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserGroupMembersRow{}
	for rows.Next() {
		var i ListUserGroupMembersRow
		if err := rows.Scan(&i.UserID, &i.Email, &i.AddedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserGroups = `-- name: ListUserGroups :many
SELECT id, name, description, member_count, created_at, created_by, updated_at, is_deleted, projection_version FROM user_groups_projection WHERE is_deleted = FALSE ORDER BY name LIMIT $1 OFFSET $2
`

type ListUserGroupsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUserGroups(ctx context.Context, arg ListUserGroupsParams) ([]UserGroupsProjection, error) {
	rows, err := q.db.Query(ctx, listUserGroups, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserGroupsProjection{}
	for rows.Next() {
		var i UserGroupsProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberCount,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserGroupsForUser = `-- name: ListUserGroupsForUser :many
SELECT ug.id, ug.name, ug.description, ug.member_count, ug.created_at, ug.created_by, ug.updated_at, ug.is_deleted, ug.projection_version FROM user_groups_projection ug
JOIN user_group_members_projection ugm ON ugm.group_id = ug.id
WHERE ugm.user_id = $1 AND ug.is_deleted = FALSE
ORDER BY ug.name
`

func (q *Queries) ListUserGroupsForUser(ctx context.Context, userID string) ([]UserGroupsProjection, error) {
	rows, err := q.db.Query(ctx, listUserGroupsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserGroupsProjection{}
	for rows.Next() {
		var i UserGroupsProjection
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MemberCount,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.IsDeleted,
			&i.ProjectionVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserIDsWithGroupRole = `-- name: ListUserIDsWithGroupRole :many
SELECT DISTINCT ugm.user_id
FROM user_group_members_projection ugm
JOIN user_group_roles_projection ugr ON ugr.group_id = ugm.group_id
WHERE ugr.role_id = $1
`

func (q *Queries) ListUserIDsWithGroupRole(ctx context.Context, roleID string) ([]string, error) {
	rows, err := q.db.Query(ctx, listUserIDsWithGroupRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userGroupHasRole = `-- name: UserGroupHasRole :one
SELECT EXISTS(
    SELECT 1 FROM user_group_roles_projection
    WHERE group_id = $1 AND role_id = $2
) AS has_role
`

type UserGroupHasRoleParams struct {
	GroupID string `json:"group_id"`
	RoleID  string `json:"role_id"`
}

func (q *Queries) UserGroupHasRole(ctx context.Context, arg UserGroupHasRoleParams) (bool, error) {
	row := q.db.QueryRow(ctx, userGroupHasRole, arg.GroupID, arg.RoleID)
	var has_role bool
	err := row.Scan(&has_role)
	return has_role, err
}
